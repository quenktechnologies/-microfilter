{"version":3,"sources":["../src/lib.js"],"names":[],"mappings":";;;;;QA8FgB,O,GAAA,O;QAoBA,K,GAAA,K;;AAlHhB;;AAIA,SAAS,UAAT,CAAoB,KAApB,EAA2B,MAA3B,EAAmC,KAAnC,EAA0C;;AAEtC,QAAI,SAAS,OAAO,MAAP,CAAc,IAAd,CAAb;;AAEA,YAAQ,MAAR;;AAEI,aAAK,GAAL;AACI,mBAAO,KAAP,IAAgB,KAAhB;AACA;;AAEJ,aAAK,GAAL;AACI,mBAAO,KAAP,IAAgB;AACZ,qBAAK;AADO,aAAhB;AAGA;;AAEJ,aAAK,IAAL;AACI,mBAAO,KAAP,IAAgB;AACZ,sBAAM;AADM,aAAhB;AAGA;;AAEJ,aAAK,GAAL;AACI,mBAAO,KAAP,IAAgB;AACZ,qBAAK;AADO,aAAhB;AAGA;;AAEJ,aAAK,IAAL;AACI,mBAAO,KAAP,IAAgB;AACZ,sBAAM;AADM,aAAhB;AAGA;;AAEJ,aAAK,KAAL;AACI,mBAAO,KAAP,IAAgB;AACZ,qBAAK;AADO,aAAhB;AAGA;;AAEJ,aAAK,GAAL;AACI,mBAAO,KAAP,IAAgB,EAAC,QAAO,MAAM,OAAN,CAAc,qBAAd,EAAqC,MAArC,CAAR,EAAsD,UAAS,GAA/D,EAAhB;AACA;AACJ;AACI;;AAxCR;AA2CA,WAAO,MAAP;AAEH;;AAED;;;;AAIA,SAAS,iBAAT,CAA2B,IAA3B,EAAiC,GAAjC,EAAsC;;AAElC,WAAO,KAAK,GAAL,CAAS,kBAAU;;AAEtB,YAAI,CAAC,IAAI,cAAJ,CAAmB,OAAO,KAA1B,CAAL,EACI,OAAO,IAAP;;AAEJ,eAAO,WAAW,OAAO,KAAlB,EAAyB,OAAO,QAAhC,EACF,OAAO,IAAI,OAAO,KAAX,CAAP,KAA6B,UAA9B,GACA,IAAI,OAAO,KAAX,EAAkB,OAAO,KAAzB,CADA,GACkC,OAAO,KAFtC,CAAP;AAIH,KATM,EASJ,MATI,CASG;AAAA,eAAU,MAAV;AAAA,KATH,CAAP;AAWH;;AAED;;;;;;;;;;;;;;;;;;;;AAoBO,SAAS,OAAT,CAAiB,GAAjB,EAAsB,GAAtB,EAA2B;;AAE9B,QAAI,IAAI,OAAO,MAAP,CAAc,IAAd,CAAR;;AAEA,QAAI,IAAI,OAAJ,CAAY,GAAZ,CAAgB,MAAhB,GAAyB,CAA7B,EACI,EAAE,IAAF,GAAS,kBAAkB,IAAI,OAAJ,CAAY,GAA9B,EAAmC,GAAnC,CAAT;;AAEJ,QAAI,IAAI,OAAJ,CAAY,EAAZ,CAAe,MAAf,GAAwB,CAA5B,EACI,EAAE,GAAF,GAAQ,kBAAkB,IAAI,OAAJ,CAAY,EAA9B,EAAkC,GAAlC,CAAR;;AAEJ,WAAO,CAAP;AAEH;;AAED;;;;;;AAMO,SAAS,KAAT,CAAe,MAAf,EAAuB;AAC1B,WAAO,eAAO,KAAP,CAAa,MAAb,CAAP;AACH","file":"lib.js","sourcesContent":["import {\n    parser\n} from './parser';\n\nfunction get_clause(field, symbol, value) {\n\n    var clause = Object.create(null);\n\n    switch (symbol) {\n\n        case '=':\n            clause[field] = value;\n            break;\n\n        case '>':\n            clause[field] = {\n                $gt: value\n            };\n            break;\n\n        case '>=':\n            clause[field] = {\n                $gte: value\n            };\n            break;\n\n        case '<':\n            clause[field] = {\n                $lt: value\n            };\n            break;\n\n        case '<=':\n            clause[field] = {\n                $lte: value\n            };\n            break;\n\n        case '$in':\n            clause[field] = {\n                $in: value\n            };\n            break;\n\n        case '?':\n            clause[field] = {$regex:value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"), $options:'i'};\n            break;\n        default:\n            break;\n\n    }\n    return clause;\n\n}\n\n/**\n * filter_conversion filters out the unknown fields before converting them.\n * @return {array}\n */\nfunction filter_conversion(list, map) {\n\n    return list.map(clause => {\n\n        if (!map.hasOwnProperty(clause.field))\n            return null;\n\n        return get_clause(clause.field, clause.operator,\n            (typeof map[clause.field] === 'function') ?\n            map[clause.field](clause.value) : clause.value);\n\n    }).filter(clause => clause);\n\n}\n\n/**\n * convert is a function that takes the AST\n * and turns it into a query. Currently preforms no optimisations\n * so expensive queries are possible. Also this does no\n * real validation of filter criteria, use a map of functions\n * to intercept potentially dangerous values.\n *\n * @todo Perhaps provide a syntax to declare what operators \n * are valid for a particular key? Maybe in the map like so:\n *  ```javascript {\n *       name: {valid_ops:['?', '='], check:x=>}\n *     }\n *  ```\n *\n * Be careful...\n * @param {AST} ast The result of a successful parse call.\n * @param {object} map A map that indicates what are valid fields. \n *                     If the value the value of the map keys are functions\n *                     they will each be called when their field is detected.\n */\nexport function convert(ast, map) {\n\n    var q = Object.create(null);\n\n    if (ast.filters.AND.length > 0)\n        q.$and = filter_conversion(ast.filters.AND, map);\n\n    if (ast.filters.OR.length > 1)\n        q.$or = filter_conversion(ast.filters.OR, map);\n\n    return q;\n\n}\n\n/**\n * parse parses a string into an\n * abstract syntax tree (ast)\n * @param {string} source\n * @returns {object}\n */\nexport function parse(source) {\n    return parser.parse(source);\n}\n"]}